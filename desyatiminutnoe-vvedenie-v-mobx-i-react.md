# Десятиминутное введение в MobX и React

{% hint style="info" %}
Оригинал этой страницы доступен [здесь](https://mobx.js.org/getting-started).
{% endhint %}

[MobX](https://github.com/mobxjs/mobx) — это простое, масштабируемое и проверенное в боевых условиях решение для управления состоянием. Этот учебник научит вас всем важным концепциям MobX за десять минут. MobX — это отдельная библиотека, но многие разработчики используют ее вместе с React, и данное руководство посвящено этой комбинации.

### Основная идея

Состояние — это сердце каждого приложения и нет более быстрого способа создать неуправляемые приложения с ошибками, чем создание несогласованного состояния или состояния, не синхронизированного с локальными переменными. Следовательно, многие решения для управления состоянием пытаются ограничить способы изменения состояния, например, делая его неизменяемым. Но это вводит новые проблемы: данные должны быть нормализованы, ссылочная целостность больше не может быть гарантирована, и становится почти невозможным использовать мощные концепции, такие как классы (если они вам нравятся).

MobX упрощает управление состоянием, решая основную проблему: он делает невозможным создание несогласованного состояния. Стратегия для достижения этого проста: _все, что может быть получено из состояния приложения, будет получено. Автоматически_.

Концептуально MobX рассматривает ваше приложение как электронную таблицу.

![](.gitbook/assets/ru\_overview.png)

1. Прежде всего, это _состояние приложения_. Состояние - это граф объектов, массивов, примитивов и ссылок, формирующих модель вашего приложения. Эти значения являются «ячейками данных» вашего приложения.
2. Во-вторых, есть производные. По сути, любое значение, которое может быть вычислено автоматически на основе состояния вашего приложения. Эти производные или вычисляемые значения могут варьироваться от простых значений, таких как количество незавершенных задач, до сложных вещей, таких как визуальное HTML-представление ваших задач. В терминах электронных таблиц: это формулы и диаграммы вашего приложения.
3. Реакции очень похожи на производные. Основное отличие состоит в том, что эти функции не производят значения. Вместо этого они автоматически запускаются для выполнения какой-либо задачи. Обычно это связано с вводом-выводом. Они следят за тем, чтобы DOM-дерево обновлялос или чтобы сетевые запросы выполнялись автоматически в нужное время.
4. Наконец, есть действия. Действия — это всё, что изменяет состояние. MobX позаботится о том, чтобы все изменения состояния приложения, вызванные вашими действиями, автоматически обрабатывались всеми производными и реакциями. Синхронно и без глюков.

### Простое состояние для списка дел

Довольно теории, практический пример, вероятно, объясняет больше, чем внимательное чтение всего вышеперечисленного. Ради оригинальности давайте начнем с очень простого состояния ToDo. Обратите внимание, что все приведенные ниже блоки кода доступны для редактирования, поэтому используйте кнопки запуска кода для их выполнения. Ниже представлен очень простой <mark style="color:blue;">TodoStore</mark>, в котором хранится коллекция задач. _**MobX еще не задействован**_.



{% embed url="https://codepen.io/nick-the-dev/pen/bGoxYVg" %}

Мы только что создали экземпляр <mark style="color:blue;">todoStore</mark> с коллекцией <mark style="color:blue;">todos</mark>. Пришло время заполнить <mark style="color:blue;">todoStore</mark> некоторыми объектами. Чтобы убедиться, что мы видим результаты наших изменений, мы вызываем <mark style="color:blue;">todoStore.report</mark> после каждого изменения и регистрируем его. Обратите внимание, что в логе намеренно всегда печатается только первая задача. Это делает этот пример немного "притянутым за уши", но, как мы увидим позже, он хорошо демонстрирует _динамическое_ отслеживание зависимостей в MobX .

```
todoStore.addTodo("прочитать руководство по MobX");
console.log(todoStore.report());

todoStore.addTodo("попробовать MobX");
console.log(todoStore.report());

todoStore.todos[0].completed = true;
console.log(todoStore.report());

todoStore.todos[1].task = "попробовать MobX в собственном проекте";
console.log(todoStore.report());

todoStore.todos[0].task = "разобраться с руководством по MobX";
console.log(todoStore.report());
```

В итоге получаем следующий вывод:

```
Следующая задача: "прочитать руководство по MobX". Прогресс: 0/1
Следующая задача: "прочитать руководство по MobX". Прогресс: 0/2
Следующая задача: "попробовать MobX". Прогресс: 1/2
Следующая задача: "попробовать MobX в собственном проекте". Прогресс: 1/2
Следующая задача: "попробовать MobX в собственном проекте". Прогресс: 1/2
```

### Добавляем реактивность

Пока ничего особенного в этом коде нет. Но было бы круто, если бы нам не нужно было явно вызывать метод <mark style="color:blue;">report</mark>. Вместо этого, мы могли бы объявить, что он должен автоматически вызываться при каждом соответствующем изменении состояния. Это освободило бы нас от ответственности за вызов метода <mark style="color:blue;">report</mark> из любого места в нашей кодовой базе. Мы хотим быть уверены, что актуальный отчет будет напечатан, но мы не хотим утруждать себя организацией этого процесса.

К счастью, это именно то, что MobX может сделать для нас. MobX будет автоматически выполнять код зависящий исключительно от состояния. Так что наша функция <mark style="color:blue;">report</mark> обновляется автоматически, как диаграмма в электронной таблице. Для этого <mark style="color:blue;">TodoStore</mark> должен стать доступным для наблюдения, чтобы MobX мог отслеживать все вносимые изменения. Давайте изменим класс ровно настолько, чтобы добиться этого.

Кроме того, свойство <mark style="color:blue;">CompletedTodosCount</mark> может быть получено автоматически из списка задач. Используя пометки <mark style="color:blue;">observable</mark> (наблюдаемый) и <mark style="color:blue;">computed</mark> (вычисляемое свойство), мы можем ввести наблюдаемые свойства объекта. В приведенном ниже примере мы используем <mark style="color:blue;">makeObservable</mark> для явного отображения пометок, но вместо этого мы могли бы использовать <mark style="color:blue;">makeAutoObservable(this)</mark> для упрощения этого процесса.

{% embed url="https://codepen.io/nick-the-dev/pen/LYzJQJg" %}

Вот и все! Мы пометили некоторые свойства как <mark style="color:blue;">observable</mark>, чтобы сообщить MobX, что эти значения могут меняться со временем. Вычисляемые свойства помечены как <mark style="color:blue;">computed</mark> для указания того, что они могут быть получены из состояния и кэша (если базовое состояние не изменилось).

Атрибуты <mark style="color:blue;">pendingRequests</mark> и <mark style="color:blue;">assignee</mark> пока не используются, но будут использованы в этом руководстве позднее.

В конструкторе мы создали небольшую функцию, которая печатает отчет и заворачивает его в <mark style="color:blue;">autorun</mark>. Автозапуск создает реакцию, которая будет запущена один раз при инициализации, а затем будет автоматически запускаться повторно всякий раз, когда изменяются какие-либо наблюдаемые значения, используемые внутри функции. Поскольку в функции <mark style="color:blue;">report</mark> используется наблюдаемое свойство <mark style="color:blue;">todos</mark>, то отчет будет распечатываться каждый раз при изменении коллекции <mark style="color:blue;">todos</mark>. Это продемонстрировано в следующем листинге.

```
observableTodoStore.addTodo("read MobX tutorial");
observableTodoStore.addTodo("try MobX");
observableTodoStore.todos[0].completed = true;
observableTodoStore.todos[1].task = "try MobX in own project";
observableTodoStore.todos[0].task = "grok MobX tutorial";<нет задач>
// пятая строка не приводит к выводу новой строки отчета
```

Получаем следующий вывод:

```
Следующая задача: "прочитать руководство по MobX". Прогресс: 0/1
Следующая задача: "прочитать руководство по MobX". Прогресс: 0/2
Следующая задача: "попробовать MobX". Прогресс: 1/2
Следующая задача: "попробовать MobX в собственном проекте". Прогресс: 1/2
```

Неплохо, да? Отчет выводился на экран автоматически, синхронно и без утечки промежуточных значений. Если вы внимательно изучите консольный лог, то увидите, что пятая строка не привела к появлению новой строки журнала. Это происходит потому, что отчет фактически не изменился в результате переименования, хотя вспомогательные данные изменились. С другой стороны, изменение имени первой задачи действительно обновило отчет, поскольку это имя активно используется в отчете. Это хорошо демонстрирует, что <mark style="color:blue;">autorun</mark> отслеживает не только массив todos, но и отдельные свойства внутри элементов <mark style="color:blue;">todo</mark>.

### Делаем React реактивным

Хорошо, пока что мы сделали примитивный отчет реактивным. Пришло время создать реактивный пользовательский интерфейс вокруг этого хранилища данных. Компоненты React (несмотря на свое название) изначально не являются реактивными. HoC-обертка <mark style="color:blue;">observer</mark>, из пакета <mark style="color:blue;">mobx-react-lite</mark> исправляет это, оборачивая компонент React в <mark style="color:blue;">autorun</mark>. Для автоматической синхронизации компонентов с состоянием. Концептуально это не отличается от того, что мы делали с отчетом ранее.

В следующем листинге определены несколько компонентов React. Единственный специфичный для MobX код — это <mark style="color:blue;">observer</mark>-оболочка наблюдателя. Этого достаточно, чтобы каждый компонент React индивидуально перерисовывался при изменении соответствующих данных. Нам больше не нужно вызывать установщики состояния <mark style="color:blue;">useState</mark>, а также нам не нужно думать о том, как подписаться на нужные части состояния приложения, используя селекторы или компоненты более высокого порядка, нуждающиеся в настройке. Теперь большинство компонентов стали "умными". Тем не менее, они определены в немой, декларативной манере.

Нажмите кнопку «Run Pen», чтобы увидеть приведенный ниже код в действии. Список доступен для редактирования, так что не стесняйтесь играть с ним. Попробуйте, например, удалить все вызовы наблюдателя (<mark style="color:blue;">observers</mark>) или только тот, который украшает <mark style="color:blue;">TodoView</mark>. Цифры в предварительном просмотре справа показывают, как часто компонент перерисовывается.

{% embed url="https://codesandbox.io/s/mobx-guide-making-react-reactive-5xp1k?file=%2Fsrc%2Findex.js" %}
Нажмите кнопку "Open Sandbox" чтобы увидеть полную версию проекта.&#x20;
{% endembed %}

Следующий листинг прекрасно демонстрирует, что нам нужно только изменить данные, не выполняя никаких дополнительных действий. MobX автоматически выведет и обновит соответствующие части пользовательского интерфейса при изменении состояния.

```
const store = observableTodoStore; 
store.todos[0].completed = !store.todos[0].completed; 
store.todos[1].task = "Random todo " + Math.random();
store.todos.push({ task: "Find a fine cheese", completed: true });
// и так далее, и так далее... можете добавить свой код в примере выше
```

### Работа со ссылками

До сих пор мы создавали наблюдаемые объекты (как прототипы, так и простые объекты), массивы и примитивы. Вам может быть интересно, как обрабатываются ссылки в MobX? Может ли моё состояние формировать граф? В предыдущих листингах вы могли заметить, что в <mark style="color:blue;">todos</mark> есть свойство <mark style="color:blue;">assignee</mark>. Давайте предоставим им некоторые значения, представив еще одно «хранилище» (хорошо, это просто старый-добрый массив), содержащее людей, а затем назначим им задачи.

{% embed url="https://codesandbox.io/s/mobx-guide-working-with-references-mdzc7" %}
Нажмите кнопку "Open Sandbox" чтобы увидеть полную версию проекта.
{% endembed %}

Теперь у нас есть два независимых хранилища. Один хранит имена людей, другой список задач todos. Чтобы назначить исполнителя задачи из хранилища имён людей, мы просто присвоили ссылку. Эти изменения будут автоматически подхвачены <mark style="color:blue;">TodoView</mark>. С MobX нет необходимости сначала нормализовать данные и писать селекторы, чтобы компоненты обновлялись автоматически. На самом деле, даже не имеет значения, где хранятся данные. Пока объекты доступны для наблюдения, MobX сможет их отслеживать (благодаря работе настоящих JavaScript ссылок). MobX будет отслеживать их автоматически, если они имеют отношение к производным. Чтобы проверить это, просто попробуйте изменить свое имя в поле ввода.

Кстати, HTML приведенного выше поля ввода выглядит довольно **** просто:

```
<input onkeyup="peopleStore[1].name = event.target.value" />
```

### Асинхронные действия

Поскольку все в нашем маленьком приложении Todo основано на состоянии, на самом деле не имеет значения, когда состояние изменяется. Это делает создание асинхронных действий очень простым. Просто нажмите следующую кнопку (несколько раз), чтобы эмулировать асинхронную загрузку новых элементов задач:

{% embed url="https://codesandbox.io/s/mobx-guide-asynchronous-actions-golo5" %}
Нажмите кнопку "Open Sandbox" чтобы увидеть полную версию проекта.
{% endembed %}

Код, стоящий за этим, действительно прост. Мы начинаем с обновления свойства хранилища <mark style="color:blue;">pendingRequests</mark>, чтобы пользовательский интерфейс отражал текущий статус загрузки. После завершения загрузки мы обновляем хранилище задач todos и снова уменьшаем счетчик <mark style="color:blue;">pendingRequests</mark>. Просто сравните этот фрагмент с более ранним определением <mark style="color:blue;">TodoList</mark>, чтобы увидеть, как используется свойство pendingRequests.

Обратите внимание, что функция тайм-аута завернута в <mark style="color:blue;">action</mark> (действие). Это не является строго обязательным, но гарантирует, что обе мутации обрабатываются в одной транзакции, гарантируя, что любые наблюдатели (observer'ы) будут уведомлены только после завершения обоих обновлений.

```
observableTodoStore.pendingRequests++;
setTimeout(action(() => {
  observableTodoStore.addTodo('Random Todo ' + Math.random());
  observableTodoStore.pendingRequests--;
}), 2000);
```

### Заключение

Это все! Никаких шаблонов. Просто несколько простых декларативных компонентов, формирующих наш пользовательский интерфейс. Они выведены полностью и реактивно из нашего состояния. Теперь вы готовы начать использовать пакеты <mark style="color:blue;">mobx</mark> и <mark style="color:blue;">mobx-react-lit</mark>e в своих приложениях. Краткий обзор того, что вы уже узнали:

1. Используйте декоратор <mark style="color:blue;">observable</mark> или <mark style="color:blue;">observable(объект или массив)</mark>, чтобы сделать объекты отслеживаемыми для MobX.
2. Декоратор <mark style="color:blue;">computed</mark> можно использовать для создания функций, которые могут автоматически извлекать значения из состояния и кэшировать их.
3. Используйте <mark style="color:blue;">autorun</mark> для автоматического запуска функций, зависящих от некоторого наблюдаемого состояния. Это полезно для ведения журнала, создания сетевых запросов и т. д.
4. Используйте обёртку <mark style="color:blue;">observer</mark> из пакета <mark style="color:blue;">mobx-react-lite</mark>, чтобы сделать ваши компоненты React по-настоящему реактивными. Они будут обновляться автоматически и эффективно. Даже при использовании в больших сложных приложениях с большими объемами данных.

Не стесняйтесь немного поиграть с редактируемыми блоками кода выше для получения базового представления о том, как MobX реагирует на все ваши изменения. Например, вы можете добавить оператор log в функцию <mark style="color:blue;">report</mark>, чтобы увидеть, когда она вызывается. Или вообще не показывать отчет и посмотреть, как это повлияет на отображение <mark style="color:blue;">TodoList</mark>.

### MobX не диктует архитектуру

Обратите внимание, что приведенные выше примеры надуманны. Рекомендуется использовать надлежащие инженерные методы, такие как инкапсуляция логики в методах, организация их в хранилищах или контроллерах, моделях представлений и т. д. Можно применять множество различных архитектурных шаблонов, и некоторые из них обсуждаются в официальной документации. Приведенные выше примеры и примеры показывают, как _можно_ использовать MobX, а не как его _следует_ использовать. Или, как выразился кто-то из HackerNews:

> «MobX упоминается много где, но я не могу не восхвалять его. Написание кода с MobX означает, что использование контроллеров/диспетчеров/действий/супервизоров или другой формы управления потоком данных снова становится архитектурной проблемой, которую вы можете приспособить к потребностям своего приложения, а не чем-то, что требуется по умолчанию для чего-то большего, чем приложение Todo».

MobX поддерживается пользователем [mweststrate](https://twitter.com/mweststrate)
